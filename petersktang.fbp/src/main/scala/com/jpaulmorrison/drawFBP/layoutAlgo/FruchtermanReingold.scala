package com.jpaulmorrison.drawFBP.layoutAlgo

import com.google.common.graph.{EndpointPair, ImmutableGraph, MutableGraph}
import javafx.geometry.BoundingBox
import com.jpaulmorrison.drawFBP.model.VertexCoordinate

import scala.util.Random

// https://i11www.iti.kit.edu/_media/teaching/winter2016/graphvis/graphvis-ws16-v6.pdf

object ForceDirectedPlacement {


//  /**
//   * Simulates the force-directed placement layout algorithm in a new Thread.
//   *
//   * @param graph     the graph to layout
//   * @param parameter parameters for the simulation
//   * @throws ParseException when the Strings in parameter that represent the force functions are malformed or empty
//   */
//  @throws[ParseException]
//  def simulate(graph: Graph[Vertex, Edge], parameter: Parameter): Unit = {
//    Executors.newSingleThreadExecutor.submit(new Simulation(graph, parameter))
//  }
//
//  /**
//   * Tries to find optimal cooling rates for the Graph generated by the given GraphGenerator and the given forces.
//   *
//   * @param config     the GraphGenerator and parameters as GraphConfiguration object
//   * @param from       initial cooling rate, must be greater 0 and less than 1.
//   * @param to         maximum cooling rate, must be greater 0 and less than 1.
//   * @param stepSize   currently tested cooling rate is increased by stepSize every step, must be greater 0.
//   * @param sampleSize for every cooling rate tested, sampleSize samples are taken and the average iterations used is calculated from them
//   * @return a list of XYChart.Data objects, containing a mapping between cooling rate and iterations
//   * @throws ParseException
//   */
//  @throws[ParseException]
//  def optimizeCoolingRate(config: GraphConfiguration, from: Double, to: Double, stepSize: Double, sampleSize: Int): List[XYChart.Data[Double, Integer]] = {
//    val p = config.getParameter
//    val chartValues = new ArrayList[XYChart.Data[Double, Integer]]
//    val exec = Executors.newFixedThreadPool(sampleSize)
//    val currResults = new ArrayList[Future[Integer]]
//    config.getParameter.setEquilibriumCriterion(true)
//    p.setFrameDelay(0)
//    // need sampleSize objects of the same graph, because we will simulate them in parallel
//    val graphs = new ArrayList[Graph[Vertex, Edge]]
//    IntStream.range(0, sampleSize).forEach((i: Int) => graphs.add(config.generateGraph))
//    // for every cooling rate to test, simulate sampleSize graph layouts in parallel, retrieve the iterations used until equilibrium,
//    // and calculate the average number of iterations for that cooling rate
//    var currentCoolingRate = from
//    while ( {
//      currentCoolingRate <= to
//    }) {
//      var iterationsUsed = 0
//      p.setCoolingRate(currentCoolingRate)
//      var i = 0
//      while ( {
//        i < sampleSize
//      }) {
//        currResults.add(exec.submit(new Simulation(graphs.get(i), p)))
//
//        {
//          i += 1; i - 1
//        }
//      }
//      // collect the results, i.e. wait for all threads to finish
//      import scala.collection.JavaConversions._
//      for (result <- currResults) {
//        try iterationsUsed += result.get
//        catch {
//          case e@(_: InterruptedException | _: ExecutionException) =>
//            e.printStackTrace()
//        }
//      }
//      // get average and save the result
//      iterationsUsed /= sampleSize
//      chartValues.add(new XYChart.Data[Double, Integer](currentCoolingRate, iterationsUsed))
//      currResults.clear()
//
//      currentCoolingRate += stepSize
//    }
//    chartValues
//  }

}

object FruchtermanReingoldLayout {
  private val AREA_MULTIPLICATOR = 100
  private val area = 100
  private case class VertexCoord(val boundingBox: BoundingBox, var dx:Double=0, var dy:Double=0)

  def goAlgo(graph:MutableGraph[Int], vertexCoordinates: Map[Int, BoundingBox]): List[(Int, Double, Double)] = {
    val maxDisplace = (Math.sqrt(AREA_MULTIPLICATOR * area) / 10f).toFloat
    val k = Math.sqrt((AREA_MULTIPLICATOR * area) / (1f + graph.nodes.size.toFloat)).toFloat

    import scala.jdk.CollectionConverters._
    val nodes = graph.nodes.asInstanceOf[java.util.Set[Int]].asScala.map{ fbp:Int => (fbp, VertexCoord(vertexCoordinates(fbp))) }.toMap[Int, VertexCoord]
    val edges = graph.edges().asInstanceOf[java.util.Set[EndpointPair[Int]]].asScala

    for (n1 <- nodes; n2 <- nodes if n1._1 != n2._1) {
      val xDist = n1._2.boundingBox.getCenterX - n2._2.boundingBox.getCenterX
      val yDist = n1._2.boundingBox.getCenterY - n2._2.boundingBox.getCenterY
      val dist = math.sqrt(xDist * xDist + yDist * yDist).toFloat
      if (dist > 0) {
        val repulsiveF = k * k / dist
        n1._2.dx = xDist / dist * repulsiveF
        n1._2.dy = yDist / dist * repulsiveF
      }
    }
    edges.foreach{ edge =>
      val s = nodes.get(edge.source()).get
      val t = nodes.get(edge.target()).get
      val xDist = s.boundingBox.getCenterX - t.boundingBox.getCenterX
      val yDist = s.boundingBox.getCenterY - t.boundingBox.getCenterY
      val dist  = math.sqrt(xDist*xDist + yDist*yDist)
      val attractiveF = dist * dist / k
      if (dist > 0){
        s.dx -= xDist / dist * attractiveF
        s.dy -= yDist / dist * attractiveF
        t.dx -= xDist / dist * attractiveF
        t.dy -= yDist / dist * attractiveF
      }
    }
    // gravity
    val gravity = 10
    nodes.foreach{ node =>
      val d = scala.math.sqrt(node._2.boundingBox.getCenterX * node._2.boundingBox.getCenterX + node._2.boundingBox.getCenterY*node._2.boundingBox.getCenterY )
      val gf = 0.01f * k * gravity * d
      node._2.dx -= gf * node._2.boundingBox.getCenterX / d
      node._2.dy -= gf * node._2.boundingBox.getCenterY / d
    }
    nodes.toList.map( node => (node._1, node._2.dx, node._2.dy) )
  }
}